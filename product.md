「第一性原理解释」对话机器人 网站设计方案 - MVP版本

## 技术栈
NextJS + Typescript（前端框架与类型安全）

不使用数据库，所有用户数据（如对话历史）存储于 localStorage

调用OpenRouter DeepSeek V3模型API进行大模型推理

**API安全架构**：
- 使用 Next.js API Routes 作为代理层，避免前端暴露API密钥
- 创建 `/api/chat` 端点处理AI推理请求
- 前端只调用内部API，由后端转发到OpenRouter

## 界面设计
响应式设计，保证手机端和电脑端访问均美观流畅

参考微信配色方案（绿色系，简洁清新）

简洁输入框与滑块控件，方便用户操作

**状态设计**：
- 加载状态：AI思考时显示动画指示器
- 错误状态：网络异常或API失败的友好提示
- 空状态：首次访问的引导界面

## 功能模块

### 1、用户输入
输入框：用户输入"想要解释的问题或情况"，例如"为什么要用第一性原理思考？"

**输入验证**：
- 防止空输入提交
- 限制单次输入最大字符数（如1000字符）
- 基础的提示词注入过滤

### 2、触发解释
"开始解释"按钮，用户点击后调用AI模型生成基于第一性原理的分解与解答

**交互状态**：
- 提交后按钮禁用，防止重复请求
- 显示"AI正在思考..."的加载提示
- 支持取消正在进行的请求

### 3、AI回答内容
根据@prompts.md提示词文档作为输出标准，返回1条基于第一性原理思维的解释内容，结构清晰，逻辑严密

**输出格式**：每条回答包含三个结构化部分：
- **问题拆解**：拆解用户问题的基本组成部分，质疑潜在假设
- **核心原理**：列举最基础的事实或真理（第一性原理）
- **创新思路**：基于第一性原理提出新颖的解决方案或视角

语气风格模仿Elon Musk的直率且富有远见的表达方式

### 4、交互优化
回答下方支持用户对AI回答进行"再解释"或"换个角度解释"的请求，形成多轮对话

**对话管理**：
- 对话历史存储在localStorage
- 支持清除单条对话记录
- 支持清空全部历史记录

### 5、错误处理机制
**网络错误**：
- API调用超时提示
- 网络连接失败提示
- 服务器错误（500）提示

**用户错误**：
- 输入为空的提示
- 输入过长的提示
- 请求频率过高的限制提示

**恢复机制**：
- 错误后支持重试功能
- 自动保存用户输入内容
- 断网恢复后自动重连

## API技术实现

**OpenRouter API配置**：
- API Key: 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
- 模型：deepseek/deepseek-chat
- Base URL: https://openrouter.ai/api/v1

**Next.js API Routes示例**：
```typescript
// /api/chat/route.ts
export async function POST(request: Request) {
  try {
    const { message } = await request.json();
    
    // 输入验证
    if (!message || message.length > 1000) {
      return Response.json({ error: '输入无效' }, { status: 400 });
    }
    
    // 调用OpenRouter API
    const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${process.env.OPENROUTER_API_KEY}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: 'deepseek/deepseek-chat',
        messages: [
          { role: 'system', content: '...' }, // prompts.md内容
          { role: 'user', content: message }
        ]
      })
    });
    
    if (!response.ok) {
      throw new Error('API调用失败');
    }
    
    const data = await response.json();
    return Response.json({ 
      content: data.choices[0].message.content 
    });
    
  } catch (error) {
    return Response.json({ 
      error: 'AI服务暂时不可用，请稍后重试' 
    }, { status: 500 });
  }
}
```

## 环境变量配置
```
OPENROUTER_API_KEY=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
NEXT_PUBLIC_SITE_NAME=第一性原理解读机器人
```

## 分版本开发计划

### 🎬 **V1.0 - 核心验证版** (2-3天)
**开发目标**：验证核心技术路径，实现最基本的对话功能

**功能清单**：
- ✅ NextJS + TypeScript 项目初始化
- ✅ 基础聊天界面搭建
  - 输入框组件（支持多行文本）
  - 消息列表显示组件
  - 简单的发送按钮
- ✅ API Routes 代理层实现
  - `/api/chat/route.ts` 端点创建
  - OpenRouter API 集成调试
  - 环境变量配置
- ✅ 核心对话功能
  - prompts.md 提示词系统集成
  - 基础的请求/响应处理
  - 简单的消息状态管理
- ✅ 基础样式实现（桌面端优先）

**验收标准**：
- 用户可以输入问题并获得结构化的第一性原理解答
- API调用稳定工作，响应时间可接受
- 界面基本可用，无明显UI错误
- 控制台无关键错误信息

**技术重点**：
- OpenRouter API 调试和错误排查
- 提示词效果验证和优化
- NextJS App Router 路由配置

---

### 🛡️ **V2.0 - 体验优化版** (3-4天)
**开发目标**：完善用户体验，处理各种异常情况和边界场景

**功能清单**：
- ✅ 完整错误处理系统
  - 网络异常捕获和提示
  - API调用失败重试机制
  - 超时处理和用户友好提示
- ✅ 交互状态优化
  - 加载动画和进度指示器
  - 按钮禁用状态管理
  - 请求取消功能
- ✅ 输入验证和安全防护
  - 空输入和长度限制
  - 基础提示词注入过滤
  - 请求频率限制
- ✅ 数据持久化
  - localStorage 对话历史存储
  - 数据序列化和反序列化
  - 存储容量监控和清理
- ✅ 用户体验细节
  - 输入框自动聚焦
  - 消息自动滚动到底部
  - 快捷键支持（Enter发送）

**验收标准**：
- 所有错误场景都有清晰的用户提示
- 加载状态明确，用户不会感到困惑
- 对话历史正确保存和恢复
- 网络异常后可以正常恢复使用
- 输入体验流畅，无卡顿现象

**技术重点**：
- 错误边界处理和用户体验设计
- localStorage 数据管理策略
- 防抖节流和性能优化

---

### 📱 **V3.0 - 产品完善版** (2-3天)
**开发目标**：完善产品细节，达到正式上线标准

**功能清单**：
- ✅ 响应式设计完善
  - 移动端界面适配
  - 触摸操作优化
  - 不同屏幕尺寸测试
- ✅ 对话历史管理
  - 历史记录列表展示
  - 单条对话删除功能
  - 清空全部历史记录
  - 对话搜索和筛选
- ✅ 多轮对话增强
  - "再解释"和"换个角度"按钮
  - 上下文关联优化
  - 对话分支管理
- ✅ UI/UX 精细化
  - 微信绿色主题完整实现
  - 动画效果和过渡
  - 图标和视觉元素优化
  - 空状态和引导页面
- ✅ 性能优化
  - 长对话列表虚拟滚动
  - 图片和资源懒加载
  - 代码分割和按需加载

**验收标准**：
- 移动端体验流畅，操作便捷
- 所有交互细节完善，符合用户习惯
- 界面美观，符合设计规范
- 性能表现良好，加载速度快
- 支持多轮深度对话

**技术重点**：
- 移动端触摸交互优化
- 虚拟滚动性能实现
- CSS动画和微交互设计

## 开发时间线

| 版本 | 开发周期 | 累计时间 | 主要里程碑 |
|------|----------|----------|------------|
| V1.0 | 2-3天 | 2-3天 | 核心功能可用 |
| V2.0 | 3-4天 | 5-7天 | 用户体验完善 |
| V3.0 | 2-3天 | 7-10天 | 产品正式发布 |

## 版本间依赖关系

```
V1.0 (核心功能) 
  ↓
V2.0 (体验优化) 
  ↓  
V3.0 (产品完善)
```

**版本切换策略**：
- 每个版本完成后进行用户测试
- 根据反馈调整后续版本功能优先级
- 保持代码结构清晰，便于迭代升级

## MVP最终交付标准
✅ 用户可以输入问题并获得结构化的第一性原理解答
✅ 支持多轮对话和历史记录管理
✅ 完善的加载状态和错误处理
✅ 移动端响应式设计
✅ API密钥安全保护
✅ 基础的输入验证和安全防护
✅ 优秀的用户体验和界面设计